import { p as prepare_files, u as upload } from './index-33d9a84d.js';
import './Index-57549946.js';
/* empty css                                                     */
/* home/runner/work/gradio/gradio/js/upload/src/Upload.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent,
	append,
	attr,
	binding_callbacks,
	bubble,
	create_slot,
	detach,
	element,
	get_all_dirty_from_scope,
	get_slot_changes,
	init,
	insert,
	listen,
	prevent_default,
	run_all,
	safe_not_equal,
	set_style,
	space,
	stop_propagation,
	toggle_class,
	transition_in,
	transition_out,
	update_slot_base
} = window.__gradio__svelte__internal;
const { createEventDispatcher, tick, getContext } = window.__gradio__svelte__internal;
function create_fragment(ctx) {
	let button;
	let t;
	let input;
	let input_multiple_value;
	let input_webkitdirectory_value;
	let input_mozdirectory_value;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[17].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);

	return {
		c() {
			button = element("button");
			if (default_slot) default_slot.c();
			t = space();
			input = element("input");
			attr(input, "type", "file");
			attr(input, "accept", /*filetype*/ ctx[0]);
			input.multiple = input_multiple_value = /*file_count*/ ctx[4] === "multiple" || undefined;
			attr(input, "webkitdirectory", input_webkitdirectory_value = /*file_count*/ ctx[4] === "directory" || undefined);
			attr(input, "mozdirectory", input_mozdirectory_value = /*file_count*/ ctx[4] === "directory" || undefined);
			attr(input, "class", "svelte-1qhocss");
			attr(button, "class", "svelte-1qhocss");
			toggle_class(button, "hidden", /*hidden*/ ctx[5]);
			toggle_class(button, "center", /*center*/ ctx[2]);
			toggle_class(button, "boundedheight", /*boundedheight*/ ctx[1]);
			toggle_class(button, "flex", /*flex*/ ctx[3]);
			set_style(button, "height", /*include_sources*/ ctx[6] ? "calc(100% - 40px" : "100%");
		},
		m(target, anchor) {
			insert(target, button, anchor);

			if (default_slot) {
				default_slot.m(button, null);
			}

			append(button, t);
			append(button, input);
			/*input_binding*/ ctx[25](input);
			current = true;

			if (!mounted) {
				dispose = [
					listen(input, "change", /*load_files_from_upload*/ ctx[10]),
					listen(button, "drag", stop_propagation(prevent_default(/*drag_handler*/ ctx[18]))),
					listen(button, "dragstart", stop_propagation(prevent_default(/*dragstart_handler*/ ctx[19]))),
					listen(button, "dragend", stop_propagation(prevent_default(/*dragend_handler*/ ctx[20]))),
					listen(button, "dragover", stop_propagation(prevent_default(/*dragover_handler*/ ctx[21]))),
					listen(button, "dragenter", stop_propagation(prevent_default(/*dragenter_handler*/ ctx[22]))),
					listen(button, "dragleave", stop_propagation(prevent_default(/*dragleave_handler*/ ctx[23]))),
					listen(button, "drop", stop_propagation(prevent_default(/*drop_handler*/ ctx[24]))),
					listen(button, "click", /*open_file_upload*/ ctx[7]),
					listen(button, "drop", /*loadFilesFromDrop*/ ctx[11]),
					listen(button, "dragenter", /*updateDragging*/ ctx[9]),
					listen(button, "dragleave", /*updateDragging*/ ctx[9])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 65536)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[16],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[16])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[16], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*filetype*/ 1) {
				attr(input, "accept", /*filetype*/ ctx[0]);
			}

			if (!current || dirty & /*file_count*/ 16 && input_multiple_value !== (input_multiple_value = /*file_count*/ ctx[4] === "multiple" || undefined)) {
				input.multiple = input_multiple_value;
			}

			if (!current || dirty & /*file_count*/ 16 && input_webkitdirectory_value !== (input_webkitdirectory_value = /*file_count*/ ctx[4] === "directory" || undefined)) {
				attr(input, "webkitdirectory", input_webkitdirectory_value);
			}

			if (!current || dirty & /*file_count*/ 16 && input_mozdirectory_value !== (input_mozdirectory_value = /*file_count*/ ctx[4] === "directory" || undefined)) {
				attr(input, "mozdirectory", input_mozdirectory_value);
			}

			if (!current || dirty & /*hidden*/ 32) {
				toggle_class(button, "hidden", /*hidden*/ ctx[5]);
			}

			if (!current || dirty & /*center*/ 4) {
				toggle_class(button, "center", /*center*/ ctx[2]);
			}

			if (!current || dirty & /*boundedheight*/ 2) {
				toggle_class(button, "boundedheight", /*boundedheight*/ ctx[1]);
			}

			if (!current || dirty & /*flex*/ 8) {
				toggle_class(button, "flex", /*flex*/ ctx[3]);
			}

			if (dirty & /*include_sources*/ 64) {
				set_style(button, "height", /*include_sources*/ ctx[6] ? "calc(100% - 40px" : "100%");
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(button);
			}

			if (default_slot) default_slot.d(detaching);
			/*input_binding*/ ctx[25](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function is_valid_mimetype(file_accept, mime_type) {
	if (!file_accept) {
		return true;
	}

	if (file_accept === "*") {
		return true;
	}

	if (file_accept.endsWith("/*")) {
		return mime_type.startsWith(file_accept.slice(0, -1));
	}

	return file_accept === mime_type;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { filetype = null } = $$props;
	let { dragging = false } = $$props;
	let { boundedheight = true } = $$props;
	let { center = true } = $$props;
	let { flex = true } = $$props;
	let { file_count = "single" } = $$props;
	let { disable_click = false } = $$props;
	let { root } = $$props;
	let { hidden = false } = $$props;
	let { include_sources = false } = $$props;

	// Needed for wasm support
	const upload_fn = getContext("upload_files");

	let hidden_upload;
	const dispatch = createEventDispatcher();

	function updateDragging() {
		$$invalidate(12, dragging = !dragging);
	}

	function open_file_upload() {
		if (disable_click) return;
		$$invalidate(8, hidden_upload.value = "", hidden_upload);
		hidden_upload.click();
	}

	async function handle_upload(file_data) {
		await tick();
		const _file_data = await upload(file_data, root, upload_fn);
		dispatch("load", file_count === "single" ? _file_data?.[0] : _file_data);
		return _file_data || [];
	}

	async function load_files(files) {
		if (!files.length) {
			return;
		}

		let _files = files.map(f => new File([f], f.name));
		let file_data = await prepare_files(_files);
		return await handle_upload(file_data);
	}

	async function load_files_from_upload(e) {
		const target = e.target;
		if (!target.files) return;
		await load_files(Array.from(target.files));
	}

	async function loadFilesFromDrop(e) {
		$$invalidate(12, dragging = false);
		if (!e.dataTransfer?.files) return;

		const files_to_load = Array.from(e.dataTransfer.files).filter(f => {
			if (filetype?.split(",").some(m => is_valid_mimetype(m, f.type))) {
				return true;
			}

			dispatch("error", `Invalid file type only ${filetype} allowed.`);
			return false;
		});

		await load_files(files_to_load);
	}

	function drag_handler(event) {
		bubble.call(this, $$self, event);
	}

	function dragstart_handler(event) {
		bubble.call(this, $$self, event);
	}

	function dragend_handler(event) {
		bubble.call(this, $$self, event);
	}

	function dragover_handler(event) {
		bubble.call(this, $$self, event);
	}

	function dragenter_handler(event) {
		bubble.call(this, $$self, event);
	}

	function dragleave_handler(event) {
		bubble.call(this, $$self, event);
	}

	function drop_handler(event) {
		bubble.call(this, $$self, event);
	}

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			hidden_upload = $$value;
			$$invalidate(8, hidden_upload);
		});
	}

	$$self.$$set = $$props => {
		if ('filetype' in $$props) $$invalidate(0, filetype = $$props.filetype);
		if ('dragging' in $$props) $$invalidate(12, dragging = $$props.dragging);
		if ('boundedheight' in $$props) $$invalidate(1, boundedheight = $$props.boundedheight);
		if ('center' in $$props) $$invalidate(2, center = $$props.center);
		if ('flex' in $$props) $$invalidate(3, flex = $$props.flex);
		if ('file_count' in $$props) $$invalidate(4, file_count = $$props.file_count);
		if ('disable_click' in $$props) $$invalidate(13, disable_click = $$props.disable_click);
		if ('root' in $$props) $$invalidate(14, root = $$props.root);
		if ('hidden' in $$props) $$invalidate(5, hidden = $$props.hidden);
		if ('include_sources' in $$props) $$invalidate(6, include_sources = $$props.include_sources);
		if ('$$scope' in $$props) $$invalidate(16, $$scope = $$props.$$scope);
	};

	return [
		filetype,
		boundedheight,
		center,
		flex,
		file_count,
		hidden,
		include_sources,
		open_file_upload,
		hidden_upload,
		updateDragging,
		load_files_from_upload,
		loadFilesFromDrop,
		dragging,
		disable_click,
		root,
		load_files,
		$$scope,
		slots,
		drag_handler,
		dragstart_handler,
		dragend_handler,
		dragover_handler,
		dragenter_handler,
		dragleave_handler,
		drop_handler,
		input_binding
	];
}

class Upload extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			filetype: 0,
			dragging: 12,
			boundedheight: 1,
			center: 2,
			flex: 3,
			file_count: 4,
			disable_click: 13,
			root: 14,
			hidden: 5,
			include_sources: 6,
			open_file_upload: 7,
			load_files: 15
		});
	}

	get open_file_upload() {
		return this.$$.ctx[7];
	}

	get load_files() {
		return this.$$.ctx[15];
	}
}

export { Upload as U };
//# sourceMappingURL=Upload-20efc7cc.js.map
